"""
* 거스름돈 문제 (기본 예제)
- 거스름돈으로 사용가능한 동전이 500원, 100원, 50원, 10원
- 동전은 무한대로 사용가능
- 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러줘야 할 동전의 최소 개수 ?
"""

"""
* 내 접근 방법
- change = 500a + 100b + 50c + 10d
- a+b+d+c 를 최소로
- a 부터 d까지 하나의 동전에 대해 1씩 증가한다(= 동전이 큰값부터 거슬러줌)
- change값이 n보다 값이 커지면 방금증가한 동전을 빼고 다음 동전으로 넘어가며...
- 만약 n 과 change가 일치 하면 반복문을 나와서 a+b+c+d를 출력
"""

"""
* 해답
"""

n = int(input)
count = 0

# 큰 단위의 동전부터 차례대로 확인
coin_types = [500, 100, 50, 10]

for coin in coin_types:
    count += n // coin # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
    n %= coin # 다음 동전으로 넘어갈 때 남은 돈

print(coin)


"""
* 내 풀이와 해답의 풀이 방법비교
- 큰 동전부터 거슬러 준다는 접근 방법은 일치하지만 풀이 방법이 살짝다름
- 반복문의 depth 즉, 시간복잡도는 O(K) 로 일치
"""

"""
* 주의할 점
- 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로
- 작은 단위의 동전들을 종합해도 다른 해가 나올 수 없기 때문
- 예를들어 거슬러줘야할 돈이 800원일 때 사용할 수 있는 거스름돈이 500, 400, 100원 이라면
- 위 풀이 방법으론 500원짜리 한개 100원 짜리 3개 총 4개가 나오는데 실제 답은 400원 짜리 두개임
"""

"""
* 결론
- 대부분의 그리디 알고리즘 문제에서는 문제 풀이를 위한 최소한의 아이디어를 떠올리고
- 이것이 정당한지 검토를 적절히 해서 탐욕적 접근으론 해결할 수 없다면
- 다른 알고리즘을(ex. DP 등) 생각해내어 다른 방식으로 푸는 단계로 넘어가야함
"""