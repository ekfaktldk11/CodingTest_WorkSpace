"""
* 큰 수의 법칙 (난이도 '하')
- 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙
- 배열에 특정한 인데스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없음
- (2 <= N <= 1,000) / (1 <= M <= 10,000) / (1 <= K <= 10,000)

- 입력 예시
5 8 3 (배열의 크기(N), M, K)
2 4 5 4 6 (배열에 들어가는 요소들)

- 출력 예시
46
"""

"""
* 내 접근 방법
- 배열에 어떠한 요소들이 들어가도 정작 계산에 사용되는 숫자는 '가장 큰 수'(max)와 '그 다음으로 큰 수(max_n)' 총 두개의 요소임
- 최초에 max 가 K번 더해지고 거기에 max_n 이 1번 더해지며 ... 이 규칙이 반복됨
- 이 규칙이 몇번 반복 되는지를 알기 위해서는 M을 K+1로 나눈 몫을 구함
- 몫 이외에 나눈 나머지는 그 나머지 값만큼 max를 더하면 됨
"""

"""
* 내 코드
"""
N, M, K = input().split() # 공백구분 값 입력
ary = input().split() # 배열에 들어갈 요소들

N = int(N) # 배열의 크기
M = int(M)
K = int(K)

for i in range(N):
    ary[i] = int(ary[i]) # string to int

ary.sort(reverse=True) # 내림차순
t = M // (K+1)
r = M % (K+1)

val = (ary[0]*t*K) + (ary[1]*t) + ary[0]*r

print(val)

"""
* 해답
"""
# N, M, K를 공백으로 구분하여 입력받기
n, m, k = map(int, input().split())
# N개의 수를 공백으로 구분하여 입력받기
data = list(map(int, input().split()))

data.sort()
first = data[n - 1] # 가장 큰 수
second = data[n - 2] # 두 번째로 큰 수

result = 0

while True:
    for i in range(k): # 가장 큰 수 K번 더하기
        if m == 0: # m이 0이라면 반복문 탈출
            break
        result += first
        m -= 1 # 더할 때마다 1씩 빼기
        if(m == 0): # m이 0이라면 반복문 탈출
            break
    result += second # 두 번째로 큰 수를 한 번 더하기
    m -= 1 # 더할 때마다 1씩 빼기

print(result)

"""
* 내 풀이와 해답의 풀이 방법비교
- 내 풀이는 반복문을 사용하지 않고 간단한 수식으로 해결
- 정렬 알고리즘을 사용하지 않고 기본 라이브러리인 sort()를 통해 정렬 했다는 점이 일치
- 해답의 방법은 M의 크기가 커지면 커질 수록 시간 초과 판정을 받을 확률이 커짐
"""

"""
* 결론
- '가장 큰 수를 K번 더하고 두 번쨰로 큰 수를 한 번 더하는 연산' 의 접근이 중요
- 정렬 알고리즘이 아닌 .sort() 라는 기본 정렬 라이브러리 함수를 사용
"""