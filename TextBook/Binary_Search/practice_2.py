"""
* 떡볶이 떡 만들기 (난이도 '중상') 제한시간 2초
- 일정하지 않은 떡볶이 떡 길이
- 절단기에 높이를 지정하면 줄지어진 떡을 한 번에 절단
- 절단기보다 높은 떡만 잘리고
- 잘린 부분 (윗 부분)을 모아서(더해서) 손님에게 제공
- (1 <= N <= 1,000,000) / 1 <= 떡길이 <= 10억 / (1 <= M <= 2,000,000,000) /

- 입력 예시
4 6
19 15 10 17

- 출력 예시
15
"""

"""
* 내 접근 방법
- 풀이는 생각 났지만 최악의 경우에 시간복잡도가 O(NM)이 되어 제한 시간내에 풀지 못하는 접근 법이다 (그리디 방법...)
"""

"""
* 해답
"""
# 떡의 개수(N)와 요청한 떡의 길이(M)을 입력받기
n, m = list(map(int, input().split()))

# 각 떡의 개별 높이 정보를 입력받기
array = list(map(int, input().split()))

# 이진 탐색을 위하 시작점과 끝점 설정
start = 0
end = max(array)

# 이진 탐색 수행(반복적)
result = 0
while(start <= end):
    total = 0
    mid = (start + end) // 2
    for x in array:
        # 잘랐을 때 떡의 양 계산
        if x > mid:
            total += (x - mid)
    # 떡의 양이 부족한 경우 (search left part)
    if total == m:
        print(mid)
    # 떡의 양이 충분한 경우 (search right part)
    elif total < m:
        end = mid - 1
    else:
        # !!! 여기서 이진 탐색으로 절단기의 높이를 찾는 단계를 진행할 수록 최적의 result가 나온다는 것을 당연하다는 듯이 알고 있어야함
        result = mid # !!! 최대한 덜 잘랐을 때가 정답이므로, result 를 계속 기록
        start = mid + 1

# 정답 출력
print(result)


"""
* 해답의 풀이
- 최적화 문제를 '예' 또는 '아니오'로 답하는 문제(결정 문제)로 바꾸어 해결하는 파라메트릭 서치 유형의 문제
- '원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제'들 중에서 범위 내에서 조건을 만족하는 최대 최소의 값을 찾는 최적화 문제는 대부분 이진 탐색으로 해결!!
- !!!절단기의 높이(탐색 범위)는 1부터 10억까지의 정수 중 하나인데, 이처럼 큰 수를 보면 당연히 이진 탐색을 생각해 내야함
- 높이가 10억인 H를 이진탐색으로 찾으면 대략 31번 ㅏㅁㄴ에 경우의 수를 모두 고려 가능
- 이때 떡의 개수 N이 최대 100만 개이므로 이진 탐색으로 절단기의 높이 H를 바꾸어 나가면 대략 최대 3,000만 번 정도의 연산으로 문제를 풀수 있음
- 201p.g 참고
"""

"""
* 결론
- '가장 큰 수를 K번 더하고 두 번쨰로 큰 수를 한 번 더하는 연산' 의 접근이 중요
- 정렬 알고리즘이 아닌 .sort() 라는 기본 정렬 라이브러리 함수를 사용
"""