# https://programmers.co.kr/learn/courses/30/lessons/42891?language=python3

'''
* 무지의 먹방 라이브 (난이도 하?) (체감난이도 상) 316pg
- 회전판에 먹어야 할 N개의 음식 (각 1 ~ N까지 번호가 마킹되어있음)
- 각 음식을 섭취하는데 일정 시간이 소요됨
- 자세한 내용은 교재 또는 위 링크 참조
'''

'''
* 내 접근 및 풀이
(1) 매초마다 테이블에 놓여있는 음식 섭취시간을 1초씩 줄임
(2) sec 라는 시간 값과 s 라는 시간 값을 따로 둠 -> sec은 실제 진행시간을, s는 현재 음식테이블 번호를 얻기 위한 값(남은 음식이 없는 (food_time[i] == 0) 테이블은 넘어가기 위해)
(3) 원형 테이블을 하나의 1차원 배열로 생각하고 "%" 계산을 통해 테이블위치를 변경하는 자료구조를 사용

-> 일부 테스트 케이스에 대한 시간초과 발생
-> 효율성테스트에서 0점
'''

'''
* 해답
'''

import heapq

def solution(food_times, k):
    # 전체 음식을 먹는 시간보다 k 가 크거나 같다면 -1
    if sum(food_times) <= k:
        return -1

    # 시간이 작은 음식부터 빼야 하므로 우선순위 큐를 이용
    q = []
    for i in range(len(food_times)):
        # (음식 시간, 음식 번호) 형태로 우선순위 큐에 삽입
        heapq.heappush(q, (food_times[i], i + 1))

    sum_value = 0 # 먹기위해 사용한 시간
    previous = 0 # 직전에 다 먹은 음식 시간
    length = len(food_times) # 남은 음식의 개수

    # (sum_value + (현재 음식 시간 - 이전 음식 시간) * 현재 음식 개수) 와 k 를 비교
    while sum_value + ((q[0][0] - previous) * length) <= k: # 다음 반복문을 실행 해도될지 미리 검사
        now = heapq.heappop(q)[0] # 우선순위 힙에서 최소 섭취시간을 now로
        # 전에 한놈을 다먹어 치우느라 생긴 로테이션 수(previous)만큼 빼주고 length만큼 곱해줘야 현재 now를 다먹어 치울수 있는가 없는가를 while의 조건문에서 비교 가능
        sum_value += (now - previous) * length
        length -= 1 # 다먹은 음식 제외
        previous = now # 이전 음식 시간 재설정

    # 남은 음식 중에서 몇 번째 음식인지 확인하여 출력
    # 여기서 부터는 각 테이블에 남은 음식이 0이 되는지에 대한 걱정을 할 필요가 없음
    # 어차피 제한 시간내에 다 못먹는 것들임 -> 위 while 문을 벗어났을 때 heapq에 남아 있는 것들은 전부 다 못먹는 것들임
    result = sorted(q, key=lambda x: x[1]) # 음식의 번호 기준으로 정렬
    return result[(k - sum_value) % length][1] # 남은시간 % 남은 음식 수 의 음식 번호를 반환


"""
* 해답 풀이
- 이 문제 풀이의 핵심은 무조건 다먹을 수 있는 놈들을 파악후 먼저 먹어 치우고
남은시간동안 남은 음식들 중 어떤 놈이 답일지 알아내는 것임
- 513pg 직접 보는것이 좋을 듯
"""

"""
* 결론 
- 그리디 문제는 항상 '~가 작은 순 ... ~가 큰 순 ... ~ 가 적은 순 부터 확인하며 ~' 단계를 거듭할 수록 비교 또는 확인해야 할 것들이 줄어드는 방식의
코딩을 해나가야함
- 또는 brute force 방법으로 무식하게 문제를 해결해 나가야 오히려 더 쉽게 풀리는 경우도 있으니 경계할것! -> 근데 이런것들은 거저주기 문제가 대부분
"""