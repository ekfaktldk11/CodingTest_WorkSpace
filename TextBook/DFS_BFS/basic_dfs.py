# !!! 여기서 출력하는 순서는 탐색 순서(큐에 들어간 순서)임 !!!
# 문제에는 재귀에서 벗어나는 노드 순서(스택으로 따지면 pop되는 순서)를 원할 수 도 있으니 어떤 것을 출력해야 하는지 제대로 파악하는 것이 중요!
# bfs, dfs 모두 스택이나 큐에 들어가는 순간 visited[i] 해서 방문했다는 처리부터함

# DFS 메소드 정의 -> Recursion 사용!
def dfs(graph, v, visited): # graph, 현재 노드 번호, 방문유무(벡터)
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end='')
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)
    #print(v) -> 얘는 가장먼저 처리되어 재귀에서 벗어나는 노드 순서대로 출력 pop 되는 순서

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
# 1 ~ 8번 노드가 있다고 가정, 각 요소번호에 있는 값들은 해당 노드에 연결된 노드 번호들을 의미
# 1 ~ 8번 노드를 표기해주기 위해 요소번호 0은 빈칸([]) 으로 설정
# 일반적으로 인접한 노드 중에서 방문하지 않은 노드가 여러 개 있으면 번호가 낮은 순서부터 처리하기 때문에 한 노드에 연결된 노드들의 순서 또한 낮은 순 으로 설정
graph = [
    []
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)

# 출력 : 1 2 7 6 8 3 4 5
# pop 되는 순서 : 6 8 7 2 5 4 3 1