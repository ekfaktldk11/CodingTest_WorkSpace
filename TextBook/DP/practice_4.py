"""
* 효율적인 화폐 구성 (난이도 '중상')
- N가지 종류의 화폐
- 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록
- 화폐구성이 같고 순서가 다른 경우를 중복 허용 x
- 구성이 불가능할 때 -1 을 출력

- (1 <= N <= 100) / (1 <= M <= 10,000)

- 입력 예시
2 15
3
2

- 출력 예시
5
"""

"""
* 해답
"""
# 정수 N을 입력받기
n, m = map(int, input().split())

n_ary = []
for i in range(n):
    n_ary.append(int(input()))

n_ary.sort()

d = [10001] * (m + 1)
d[0] = 0

# i - k 원을 만들 수 있는 경우 & 그럴 수 없는 경우를 나눠서 탑 다운

for i in range(n):
    for j in range(n_ary[i], m + 1):
        if d[j - n_ary[i]] != 10001: # 금액 (i - k)를 만들 수 있는 경우가 존재 한다면 -> 여기서 i는 코드 상의 i와 다름 ... 코드상에선 j 와 같다고 할 수 있음
            d[j] = min(d[j], d[j - n_ary[i]] + 1)
        # else:
            # # 금액 (i - k)를 만들 수 있는 경우가 없으면 현재 있는 화폐로는 i 원을 만들 수 없음

if(d[m] == 10001):
    print(-1)
else:
    print(d[m])

"""
* 풀이
- 화폐 단위에서 큰 단위가 작은 단위의 배수가 아니라서 그리디 알고리즘에서 사용했던 것처럼 가장 큰 화폐 단위부터 처리하는 방법으로는 해결할 수 없음
- DP를 이용해서 적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾아야 함
- DP에서 중요한 !점화식! 
- 금액 i를 만들 수 있는 최소한의 화폐 개수를 a_i, 화폐의 단위를 k라고 했을 때
- a_(i-k)를 만드는 방법이 존재하는 경우 : a_i = min(a_i, a_(i-k) + 1)
- a_(i-k)를 만드는 방법이 존재하지 않는 경우 : a_i = 10,001
- a_(i-k) -> 금액 (i - k)를 만들 수 있는 최소한의 화폐 개수
- 모든 화폐 단위에 대해 위 과정을 반복하면 최소 화폐구성으로 거스름돈을 만들 수 있음
"""

"""
* 결론
- 일단 거스름돈 문제가 나오면, 화폐의 단위를 봤을 때 큰 단위가 작은 단위의 배수가 아니라면 바로 DP를 생각해 내어야 함!
- M이 1000이면 1원 부터 1000원까지 (1원, 2원, 3원, 4원 ... 1000원까지) 각 돈마다의 최소의 화폐구성을 만드는 점화식을 만들어 내어야함
"""