"""
* 1로 만들기 (난이도 '중')
- 정수 X가 주어질 때 정수 X에 사용할 수 있는 총 네가지 연산
- (1). X가 5로 나누어 떨어지면 5로 나눔
- (2). X가 3로 나누어 떨어지면 3로 나눔
- (3). X가 2로 나누어 떨어지면 2로 나눔
- (4). X에서 1을 뺌
- 위 연산을 사용해 1로 만들 때 연산을 사용하는 횟수의 최솟값을 출력하시오
- (1 <= X <= 30,000)

- 입력 예시
26

- 출력 예시
3
"""

"""
* 내 접근 방법
- 받아온 정수의 크기 + 1 만큼 배열을 선언하고 재귀함수를 사용해서 1부터 n까지의 각 최소 연산 횟수를 배열에 넣어서 문제 해결 
"""

n = int(input())

ary = [0] * (n + 1)

print(ary)

oper = [5, 3, 2]

def f(x):
    if x == 1:
        return 0
    if x == 2:
        return 1
    if x == 3:
        return 1
    if x == 4:
        return 2
    if x == 5:
        return 1

    if ary[x] != 0:
        return ary[x]

    for i in range(3):
        if x % oper[i] == 0:
            ary[x] = f(x // oper[i]) + 1
            return ary[x]
    ary[x] = f(x - 1) + 1
    return ary[x]

print(f(n))

"""
* 해답
"""
# 정수 X를 입력받기
x = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 30001

# 다이나믹 프로그래밍(Dynamic Programming) 진행
for i in range(2, x + 1):
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i - 1] + 1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    # 현재의 수가 3로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    # 현재의 수가 5로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

"""
* 풀이 비교
- 접근 방법은 비슷해보여도 답은 전혀 다르게 나온다 (내 풀이는 옳지않음)
- 내 풀이는 바텀업 방식으로 풀려했지만 재귀함수를 이용하면서 결국엔 탑다운 방식이였다
- 해답에서 중요한 포인트는 총 네 가지
- (1). 받아온 정수 만큼 배열을 생성하는 것이 아닌 이미 N의 최대 범위까지 배열을 만들어 놓음
- (2). 반복문 사용
- (3). 반복문 안에 조건문의 수가 문제에서 주어진 가능한 연산의 수랑 일치 (현재에서 1을 빼는 경우를 else 조건이라고 가정)
- (4). min(1을 뺴는 경우, 5|3|2 로 나누는 경우) 로 d[i]를 결정
"""

"""
* 결론
- 해답의 풀이 법이 눈에 확 들어오질 않음.. ㅠ
- 아무래도 이건 문제를 계속 풀어보면서 익숙해 지는 것이 중요할 듯!!
"""