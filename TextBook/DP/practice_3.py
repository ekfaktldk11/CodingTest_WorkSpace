"""
* 바닥 공사 (난이도 '중')
- 가로의 길이가 N, 세로의 길이가 2인 직사각형 형태의 얇은 바닥
- 이 바닥을 덮개의 크기가 1 * 2, 2 * 1, 2 * 2의 덮개를 이용해 채우고자 함
- 이때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성하시오.

- (1 <= N <= 1,000)

- 입력 예시
3

- 출력 예시
5
"""

"""
* 해답
"""
# 정수 N을 입력받기
n = int(input())

# 가로길이가 N 일 때 n + 1까지 반영해야함
d = [0] * 1001

d[1] = 1
d[2] = 3

for i in range(3, n + 1):
    d[i] = (d[i - 1] + (d[i - 2] * 2)) % 796796

print(d[n])

"""
* 풀이
- !! 점화식 세우기 !! 제발 !!
- 왼쪽부터 차례대로 바닥을 덮개로 채운다고 할 때 덮개 위치 i 를 채우고자 할 경우
- (1). 왼쪽부터 (i - 1)까지 길이가 덮개로 이미 채워져 있을 경우
- (2). 왼쪽부터 (i - 2)까지 길이가 덮개로 이미 채워져 있는 경우
- (1) 의 경우 2 * 1덮개 하나로 채우는 방법 하나 뿐
- (2) 의 경우 1 * 2덮개 두개로 채우는 방법과 2 * 2덮개 하나로 채우는 방법 총 두가지
- 위 두가지 만 고려하면 되는 이유는 ((i - 3)의 위치를 고려하지 않아도 되는 이유) 사용할 수 있는 덮개의 형태가 최대 2 * 2 크기의 직사각형 형태이기 때문에
- 점화식 : a_i = a_(i-1) + (a_(i-2) * 2)
- 사실상 이는 직접 그려봐도 점화식이 나올 수 있는 경우기도 한데 인접 3항간의 관계를 파악하기는 쉽지 않음
"""

"""
* 결론
- 다이나믹 프로그래밍은 메모이제이션 기법으로 캐싱 방법처럼 메모리를 사용해서 연산 속도를 높이는 것임
- 연산 속도를 높이기 위해서는 프로그래밍이 동작하는 도중에 최적의 해를 계속해서 업데이트하고 각 시행(i)에서의 최적의 해를 d[i] 같이 배열에 저장함
- 위 두가지 개념이 머리속에 제대로 확립이 되어야 다이나믹 프로그래밍을 무리 없이 해결할 수 있음!!
- 너무 어렵다
- 점화식 세우는게 조금 빡세다
"""