"""
* 개미 전사의 메뚜기가 적재해 놓은 식량 창고 털어버리기 (난이도 '중상')
- 일직선상에 존재하는 식량창고를 털 때 인접한 식량창고를 털지 않음
- 따라서 최소한 한 칸 이상 떨어진 식량창고(총 N개의 창고)를 약탈해야 함
- (3 <= N <= 100) / (0 <= K <= 1000) -> 식량창고 하나의 최대 적재 수

- 입력 예시
4
1 3 1 5

- 출력 예시
8
"""

"""
* 내 접근 방법
- 문제 풀기를 시도했지만 형편없기에 ... 따로 적지 않음 
"""

"""
* 해답
"""
# 정수 N을 입력받기
n = int(input())
# 모든 식량 정보 입력받기
array = list(map(int, input().split()))

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 다이나믹 프로그래밍(Dynamic Programming) 진행(Bottom Up)
d[0] = array[0]
d[1] = max(array[0], array[1])
for i in range(2, n):  # 3 <= N 이니까
    d[i] = max(d[i - 1], d[i - 2] + array[i])

# 계산된 결과 출력
print(d[n - 1])

"""
* 풀이
- 왼쪽부터 차례대로 식량창고를 턴다고 가정하면 어렵지 않게 점화식을 세울 수 있음
- 왼쪽부터 차례대로 식량창고를 털지 안 털지를 결정하는 경우 & 특정한 i번째 식량창고에 대해서 털지 안 털지의 여부를 결정할 때 단 두가지 경우에 대해서만 확인하면 됨
- (1). 현재 식량 창고의 위치가 i 일 때 (i - 1) 번째 식량창고를 털기로 결정한 경우 i 번째 식량창고를 털 수 없음
- (2). (i - 2)번째 식량창고를 털기로 결정한 경우 i 번째 식량창고를 털 수 있음
- (1). 과 (2). 중에서 더 많은 식량을 털 수 있는 경우를 선택하면 됨
- !! 여기서 중요한 점은 위 (1) & (2) 둘 중 하나를 결정할 때 (i - 3)번째 이하의 식량창고에 대해서는 이미 고려되어 있기 때문에 신경 쓸 필요 없다는 것
- !! 이를 위해 (1) & (2) 에서 현재 위치가 i 일 때 (i + 1) 과 (i + 2) 를 사용하는 것이 아닌 (i - 1) 과 (i - 2) 를 사용함
- 점화식 : a_(i) = max(a_(i-1), a_(i-2) + k_(i)) / a_(i) 는 i 번째 까지의 최대 식량의 양 , k_(i) 는 i 번째 창고에 들어있는 식량의 양
"""

"""
* 결론
- 다이나믹 프로그래밍은 메모이제이션 기법으로 캐싱 방법처럼 메모리를 사용해서 연산 속도를 높이는 것임
- 연산 속도를 높이기 위해서는 프로그래밍이 동작하는 도중에 최적의 해를 계속해서 업데이트하고 각 시행(i)에서의 최적의 해를 d[i] 같이 배열에 저장함
- 위 두가지 개념이 머리속에 제대로 확립이 되어야 다이나믹 프로그래밍을 무리 없이 해결할 수 있음!!
"""